defmodule VolfefeMachine.Intelligence do
  @moduledoc """
  The Intelligence context.

  Handles ML-based sentiment classification of content using FinBERT.
  This context manages the creation, retrieval, and querying of sentiment
  classifications generated by the FinBERT model.

  ## Architecture

  The Intelligence context follows Phoenix Context boundaries:
  - Calls Content context API (not direct schema access)
  - Manages Classification schema lifecycle
  - Integrates with FinBERT Python service for ML inference
  - Provides public API for other contexts

  ## Model Version

  Classifications track model_version for future model upgrades:
  - Format: "finbert-tone-v1.0"
  - Full metadata stored in meta field
  """

  import Ecto.Query, warn: false
  alias VolfefeMachine.Repo
  alias VolfefeMachine.Intelligence.Classification
  alias VolfefeMachine.Content

  @doc """
  Returns the list of classifications.

  ## Examples

      iex> list_classifications()
      [%Classification{}, ...]
  """
  def list_classifications do
    Repo.all(Classification)
  end

  @doc """
  Gets a single classification by ID.

  Raises `Ecto.NoResultsError` if the Classification does not exist.

  ## Examples

      iex> get_classification!(123)
      %Classification{}

      iex> get_classification!(456)
      ** (Ecto.NoResultsError)
  """
  def get_classification!(id), do: Repo.get!(Classification, id)

  @doc """
  Gets the classification for a specific content item.

  Returns nil if no classification exists for the content.

  ## Examples

      iex> get_classification_by_content(content_id)
      %Classification{}

      iex> get_classification_by_content(999)
      nil
  """
  def get_classification_by_content(content_id) do
    Repo.get_by(Classification, content_id: content_id)
  end

  @doc """
  Creates a classification.

  ## Examples

      iex> create_classification(%{
      ...>   content_id: 1,
      ...>   sentiment: "positive",
      ...>   confidence: 0.95,
      ...>   model_version: "finbert-tone-v1.0"
      ...> })
      {:ok, %Classification{}}

      iex> create_classification(%{sentiment: "invalid"})
      {:error, %Ecto.Changeset{}}
  """
  def create_classification(attrs \\ %{}) do
    %Classification{}
    |> Classification.changeset(attrs)
    |> Repo.insert()
  end

  @doc """
  Updates a classification.

  ## Examples

      iex> update_classification(classification, %{confidence: 0.99})
      {:ok, %Classification{}}

      iex> update_classification(classification, %{sentiment: "invalid"})
      {:error, %Ecto.Changeset{}}
  """
  def update_classification(%Classification{} = classification, attrs) do
    classification
    |> Classification.changeset(attrs)
    |> Repo.update()
  end

  @doc """
  Deletes a classification.

  ## Examples

      iex> delete_classification(classification)
      {:ok, %Classification{}}

      iex> delete_classification(classification)
      {:error, %Ecto.Changeset{}}
  """
  def delete_classification(%Classification{} = classification) do
    Repo.delete(classification)
  end

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking classification changes.

  ## Examples

      iex> change_classification(classification)
      %Ecto.Changeset{data: %Classification{}}
  """
  def change_classification(%Classification{} = classification, attrs \\ %{}) do
    Classification.changeset(classification, attrs)
  end

  @doc """
  Classifies a content item using FinBERT.

  This is the main entry point for sentiment classification. It:
  1. Fetches the content item
  2. Calls the FinBERT service for classification
  3. Stores the classification result
  4. Returns the classification

  ## Examples

      iex> classify_content(content_id)
      {:ok, %Classification{sentiment: "positive", confidence: 0.95}}

      iex> classify_content(999)
      {:error, :content_not_found}

      iex> classify_content(content_id_with_empty_text)
      {:error, :no_text_to_classify}
  """
  def classify_content(content_id) do
    with {:ok, content} <- fetch_content(content_id),
         {:ok, text} <- validate_text(content),
         {:ok, result} <- call_finbert_service(text),
         {:ok, classification} <- store_classification(content_id, result) do
      {:ok, classification}
    end
  end

  @doc """
  Batch classifies multiple content items.

  Returns a list of results with {:ok, classification} or {:error, reason}
  for each content ID.

  ## Examples

      iex> batch_classify_contents([1, 2, 3])
      [
        {:ok, %Classification{}},
        {:ok, %Classification{}},
        {:error, :no_text_to_classify}
      ]
  """
  def batch_classify_contents(content_ids) when is_list(content_ids) do
    Enum.map(content_ids, &classify_content/1)
  end

  @doc """
  Queries classifications by sentiment.

  ## Examples

      iex> list_by_sentiment("positive")
      [%Classification{sentiment: "positive"}, ...]
  """
  def list_by_sentiment(sentiment) when sentiment in ["positive", "negative", "neutral"] do
    Classification
    |> where([c], c.sentiment == ^sentiment)
    |> Repo.all()
  end

  @doc """
  Queries classifications with confidence above a threshold.

  ## Examples

      iex> list_high_confidence(0.9)
      [%Classification{confidence: 0.95}, ...]
  """
  def list_high_confidence(threshold) when is_float(threshold) do
    Classification
    |> where([c], c.confidence >= ^threshold)
    |> Repo.all()
  end

  # Private helper functions

  defp fetch_content(content_id) do
    case Content.get_content(content_id) do
      nil -> {:error, :content_not_found}
      content -> {:ok, content}
    end
  end

  defp validate_text(%{text: nil}), do: {:error, :no_text_to_classify}
  defp validate_text(%{text: ""}), do: {:error, :no_text_to_classify}
  defp validate_text(%{text: text}), do: {:ok, text}

  defp call_finbert_service(text) do
    alias VolfefeMachine.Intelligence.FinbertClient

    case FinbertClient.classify(text) do
      {:ok, result} -> {:ok, result}
      {:error, reason} -> {:error, reason}
    end
  end

  defp store_classification(content_id, result) do
    attrs = %{
      content_id: content_id,
      sentiment: result.sentiment,
      confidence: result.confidence,
      model_version: result.model_version,
      meta: result.meta
    }

    create_classification(attrs)
  end
end
